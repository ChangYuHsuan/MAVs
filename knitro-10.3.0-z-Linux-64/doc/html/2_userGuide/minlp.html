

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head><div class = "head"> </div>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Mixed-integer nonlinear programming &mdash; Artelys Knitro 10.3 User&#39;s Manual</title>
  

  
  
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/Artelys_theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../genindex.html"/>
        <link rel="search" title="Search" href="../search.html"/>
    <link rel="top" title="Artelys Knitro 10.3 User&#39;s Manual" href="../index.html"/>
        <link rel="up" title="User guide" href="../2_userGuide.html"/>
        <link rel="next" title="Complementarity constraints" href="complementarity.html"/>
        <link rel="prev" title="Multistart" href="multistart.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Artelys Knitro User's Manual
          

          
          </a>

          
            
            
              <div class="version">
                10.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../1_introduction.html">Introduction</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../2_userGuide.html">User guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="gettingStarted.html">Getting started</a></li>
<li class="toctree-l2"><a class="reference internal" href="knitroOptions.html">Setting options</a></li>
<li class="toctree-l2"><a class="reference internal" href="derivatives.html">Derivatives</a></li>
<li class="toctree-l2"><a class="reference internal" href="multistart.html">Multistart</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Mixed-integer nonlinear programming</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#ampl-example">AMPL example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#matlab-example">MATLAB example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#c-example">C example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#object-oriented-c-example">Object-oriented C++ example</a></li>
<li class="toctree-l3"><a class="reference internal" href="#minlp-options">MINLP options</a></li>
<li class="toctree-l3"><a class="reference internal" href="#algorithms-methods">Algorithms/Methods</a></li>
<li class="toctree-l3"><a class="reference internal" href="#branching-priorities">Branching priorities</a></li>
<li class="toctree-l3"><a class="reference internal" href="#special-treatment-of-integer-variables">Special Treatment of Integer Variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="#minlp-callbacks">MINLP callbacks</a></li>
<li class="toctree-l3"><a class="reference internal" href="#determining-convexity">Determining convexity</a></li>
<li class="toctree-l3"><a class="reference internal" href="#additional-examples">Additional examples</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="complementarity.html">Complementarity constraints</a></li>
<li class="toctree-l2"><a class="reference internal" href="ktrlsq.html">Nonlinear Least-Squares</a></li>
<li class="toctree-l2"><a class="reference internal" href="algorithms.html">Algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="feasibility.html">Feasibility and infeasibility</a></li>
<li class="toctree-l2"><a class="reference internal" href="parallelism.html">Parallelism</a></li>
<li class="toctree-l2"><a class="reference internal" href="tuner.html">The Knitro-Tuner</a></li>
<li class="toctree-l2"><a class="reference internal" href="termination.html">Termination criteria</a></li>
<li class="toctree-l2"><a class="reference internal" href="obtainingInformation.html">Obtaining information</a></li>
<li class="toctree-l2"><a class="reference internal" href="callbacks.html">Callbacks</a></li>
<li class="toctree-l2"><a class="reference internal" href="otherProgInterfaces.html">Other programmatic interfaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="specialProblems.html">Special problem classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="tips.html">Tips and tricks</a></li>
<li class="toctree-l2"><a class="reference internal" href="bibliography.html">Bibliography</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../3_referenceManual.html">Reference manual</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../index.html">Artelys Knitro User's Manual</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../2_userGuide.html">User guide</a> &raquo;</li>
      
    <li>Mixed-integer nonlinear programming</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="mixed-integer-nonlinear-programming">
<span id="chap-minlp"></span><h1>Mixed-integer nonlinear programming</h1>
<p id="index-0">Knitro provides tools for solving optimization models
(both linear and nonlinear) with binary or integer variables.
The Knitro mixed integer programming (MIP) code offers three
algorithms for mixed-integer nonlinear programming (MINLP).  The
first is a nonlinear branch and bound method, the second
implements the hybrid Quesada-Grossman method for convex MINLP,
and the third implements a mixed-integer Sequential Quadratic
Programming (MISQP) method that is able to handle non-relaxable
integer variables.</p>
<p>The Knitro MINLP code is designed for convex mixed integer
programming and is only a heuristic for nonconvex problems.
The MINLP code also handles mixed integer linear programs (MILP)
of moderate size.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The Knitro MIP tools do not currently handle special ordered sets
(SOS&#8217;s) or semi-continuous variables.</p>
</div>
<div class="section" id="ampl-example">
<h2>AMPL example</h2>
<p>Using MINLP features in AMPL is very simple: one only has to
declare variables as integer in the AMPL model. In our toy example,
let us modify the declaration of variable <em>x</em> as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">var</span> <span class="n">x</span><span class="p">{</span><span class="n">j</span> <span class="ow">in</span> <span class="mf">1.</span><span class="o">.</span><span class="mi">3</span><span class="p">}</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="n">integer</span><span class="p">;</span>
</pre></div>
</div>
<p>and then run the example again. The Knitro log now mentions
3 integer variables, and displays additional statistics related
to the MIP solve.</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>=======================================
          Commercial License
         Artelys Knitro 10.0.0
=======================================

Knitro changing mip_method from AUTO to 1.
Knitro changing mip_rootalg from AUTO to 1.
Knitro changing mip_lpalg from AUTO to 3.
Knitro changing mip_branchrule from AUTO to 2.
Knitro changing mip_selectrule from AUTO to 2.
Knitro changing mip_rounding from AUTO to 3.
Knitro changing mip_heuristic from AUTO to 1.
Knitro changing mip_pseudoinit from AUTO to 1.

Problem Characteristics
-----------------------
Objective goal:  Minimize
Number of variables:                     3
    bounded below:                       3
    bounded above:                       0
    bounded below and above:             0
    fixed:                               0
    free:                                0
Number of binary variables:              0
Number of integer variables:             3
Number of constraints:                   2
    linear equalities:                   1
    nonlinear equalities:                0
    linear inequalities:                 0
    nonlinear inequalities:              1
    range:                               0
Number of nonzeros in Jacobian:          6
Number of nonzeros in Hessian:           5

Knitro detected 0 GUB constraints
Knitro derived 0 knapsack covers after examining 0 constraints
Knitro solving root node relaxation

   Node    Left    Iinf     Objective         Best relaxatn  Best incumbent
  ------  ------  ------  --------------     --------------  --------------
*      1       0       0    9.360000e+02       9.360000e+02    9.360000e+02

EXIT: Optimal solution found.

Final Statistics for MIP
------------------------
Final objective value               =   9.36000000000000e+02
Final integrality gap (abs / rel)   =  0.00e+00 /   0.00e+00 ( 0.00%)
# of nodes processed                =        1
# of subproblems solved             =        2
Total program time (secs)           =       0.00829 (     0.007 CPU time)
Time spent in evaluations (secs)    =       0.00018

===========================================================================

Knitro 10.0.0: Locally optimal or satisfactory solution.
objective 936; integrality gap 0
1 nodes; 2 subproblem solves
</pre></div>
</div>
<p>Note that this example is not particularly interesting since the two solutions
we know for the continuous version of this problem are already integer &#8220;by chance&#8221;.
As a consequence, the MINLP solve returns the same solution as the continuous
solve. However, if for instance you change the first constraint to:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">s</span><span class="o">.</span><span class="n">t</span><span class="o">.</span> <span class="n">c1</span><span class="p">:</span> <span class="mi">8</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">14</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">7</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="mi">50</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>instead of:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">s</span><span class="o">.</span><span class="n">t</span><span class="o">.</span> <span class="n">c1</span><span class="p">:</span> <span class="mi">8</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">14</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">7</span><span class="o">*</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="mi">56</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>you will observe that the integer solution differs from the continuous one.</p>
</div>
<div class="section" id="matlab-example">
<h2>MATLAB example</h2>
<p>To use the MINLP features in MATLAB, one must use the function <em>knitromatlab_mip</em>,
rather than <em>knitromatlab</em>. The function signature is very similar to <em>knitromatlab</em>,
but three additional argument arrays are used.
The most elaborate form is:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">fval</span><span class="p">,</span><span class="n">exitflag</span><span class="p">,</span><span class="n">output</span><span class="p">,</span><span class="k">lambda</span><span class="p">,</span><span class="n">grad</span><span class="p">,</span><span class="n">hessian</span><span class="p">]</span> <span class="o">=</span>
        <span class="n">knitromatlab_mip</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span><span class="n">x0</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">Aeq</span><span class="p">,</span><span class="n">beq</span><span class="p">,</span><span class="n">lb</span><span class="p">,</span><span class="n">ub</span><span class="p">,</span><span class="n">nonlcon</span><span class="p">,</span><span class="o">...</span>
            <span class="n">xType</span><span class="p">,</span><span class="n">objFnType</span><span class="p">,</span><span class="n">cineqFnType</span><span class="p">,</span><span class="n">extendedFeatures</span><span class="p">,</span><span class="n">options</span><span class="p">,</span><span class="n">KnitroOptions</span><span class="p">)</span>
</pre></div>
</div>
<p>The array <em>xType</em> sets the variable types and must be the same length as <em>x0</em> if it is used.
Continuous, integer, and binary variables are set with 0, 1, and 2, respectively. Passing an
empty array, [], is equivalent to an array of all zeros.</p>
<p>The scalar <em>objFnType</em> sets the objective function type.
Uncertain, convex, and nonconvex are set with 0, 1, and 2, respectively. Passing an
empty array, [], is equivalent to passing zero.</p>
<p>The array <em>cineqFnType</em> sets the inequality constraint function types and its length must be the same as the
number of inequality constraints. Linear constraints are known to be convex, and nonlinear
equality constraints are known to be nonconvex, so they are not included in the array.
Uncertain, convex, and nonconvex inequality constraints are set with 0, 1, and 2, respectively. Passing an
empty array, [], is equivalent to passing an array of all zeros.</p>
<p>Modifying the toy example in MATLAB to use integer variables can be done as follows:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">xType</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">;</span><span class="mi">2</span><span class="p">;</span><span class="mi">2</span><span class="p">];</span>
<span class="n">objFnType</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="n">cineqFnType</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="o">%</span><span class="n">modify</span> <span class="n">the</span> <span class="n">solver</span> <span class="n">call</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">knitromatlab_mip</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">Aeq</span><span class="p">,</span> <span class="n">beq</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">,</span> <span class="o">...</span>
         <span class="n">nlcon</span><span class="p">,</span> <span class="n">xType</span><span class="p">,</span> <span class="n">objFnType</span><span class="p">,</span> <span class="n">cineqFnType</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="c-example">
<h2>C example</h2>
<p>A MIP problem is defined and solved via the callable library interface
using the API functions  <a class="reference internal" href="../3_referenceManual/callableLibrary/API.html#KTR_mip_init_problem" title="KTR_mip_init_problem"><code class="xref c c-func docutils literal"><span class="pre">KTR_mip_init_problem()</span></code></a> and
<a class="reference internal" href="../3_referenceManual/callableLibrary/API.html#KTR_mip_solve" title="KTR_mip_solve"><code class="xref c c-func docutils literal"><span class="pre">KTR_mip_solve()</span></code></a>.</p>
<p>The signature of <a class="reference internal" href="../3_referenceManual/callableLibrary/API.html#KTR_mip_init_problem" title="KTR_mip_init_problem"><code class="xref c c-func docutils literal"><span class="pre">KTR_mip_init_problem()</span></code></a> is the following.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">int</span>  <span class="n">KNITRO_API</span> <span class="nf">KTR_mip_init_problem</span> <span class="p">(</span>
        <span class="n">KTR_context_ptr</span> <span class="n">kc</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">int</span>             <span class="n">n</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">int</span>             <span class="n">objGoal</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">int</span>             <span class="n">objType</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">int</span>             <span class="n">objFnType</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">int</span>    <span class="o">*</span> <span class="k">const</span>  <span class="n">xType</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">double</span> <span class="o">*</span> <span class="k">const</span>  <span class="n">xLoBnds</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">double</span> <span class="o">*</span> <span class="k">const</span>  <span class="n">xUpBnds</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">int</span>             <span class="n">m</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">int</span>    <span class="o">*</span> <span class="k">const</span>  <span class="n">cType</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">int</span>    <span class="o">*</span> <span class="k">const</span>  <span class="n">cFnType</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">double</span> <span class="o">*</span> <span class="k">const</span>  <span class="n">cLoBnds</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">double</span> <span class="o">*</span> <span class="k">const</span>  <span class="n">cUpBnds</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">int</span>             <span class="n">nnzJ</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">int</span>    <span class="o">*</span> <span class="k">const</span>  <span class="n">jacIndexVars</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">int</span>    <span class="o">*</span> <span class="k">const</span>  <span class="n">jacIndexCons</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">int</span>             <span class="n">nnzH</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">int</span>    <span class="o">*</span> <span class="k">const</span>  <span class="n">hessIndexRows</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">int</span>    <span class="o">*</span> <span class="k">const</span>  <span class="n">hessIndexCols</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">double</span> <span class="o">*</span> <span class="k">const</span>  <span class="n">xInitial</span><span class="p">,</span>
        <span class="k">const</span> <span class="kt">double</span> <span class="o">*</span> <span class="k">const</span>  <span class="n">lambdaInitial</span><span class="p">);</span>
</pre></div>
</div>
<p>The only differences with <a class="reference internal" href="../3_referenceManual/callableLibrary/API.html#KTR_init_problem" title="KTR_init_problem"><code class="xref c c-func docutils literal"><span class="pre">KTR_init_problem()</span></code></a> are</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="kt">int</span>             <span class="n">objFnType</span><span class="p">,</span>
<span class="k">const</span> <span class="kt">int</span>    <span class="o">*</span> <span class="k">const</span>  <span class="n">xType</span><span class="p">,</span>
<span class="p">...</span>
<span class="k">const</span> <span class="kt">int</span>    <span class="o">*</span> <span class="k">const</span>  <span class="n">cFnType</span><span class="p">,</span>
</pre></div>
</div>
<p>where <em>objFnType</em> sets the objective function type (convex, nonconvex
or uncertain), <em>xType</em> sets the variable type (binary, integer or
continuous) and <em>cFnType</em> sets the constraint function type (same choices
as for the objective function).</p>
<p>The signature of <a class="reference internal" href="../3_referenceManual/callableLibrary/API.html#KTR_mip_solve" title="KTR_mip_solve"><code class="xref c c-func docutils literal"><span class="pre">KTR_mip_solve()</span></code></a> is exactly the same as for <a class="reference internal" href="../3_referenceManual/callableLibrary/API.html#KTR_solve" title="KTR_solve"><code class="xref c c-func docutils literal"><span class="pre">KTR_solve()</span></code></a>.</p>
<p>In order to turn our C toy example into a MINLP problem,
it thus suffices to replace the call to <a class="reference internal" href="../3_referenceManual/callableLibrary/API.html#KTR_init_problem" title="KTR_init_problem"><code class="xref c c-func docutils literal"><span class="pre">KTR_init_problem()</span></code></a> with</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cm">/* in the declarations */</span>
<span class="kt">int</span> <span class="n">objFnType</span> <span class="o">=</span> <span class="n">KTR_FNTYPE_NONCONVEX</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">xType</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">cFnType</span><span class="p">;</span>

<span class="cm">/* allocate and fill in the arrays */</span>
<span class="n">xType</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="n">cFnType</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="n">xType</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">KTR_VARTYPE_INTEGER</span><span class="p">;</span>
<span class="n">xType</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">KTR_VARTYPE_INTEGER</span><span class="p">;</span>
<span class="n">xType</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">KTR_VARTYPE_INTEGER</span><span class="p">;</span>
<span class="n">cFnType</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">KTR_FNTYPE_CONVEX</span><span class="p">;</span>
<span class="n">cFnType</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">KTR_FNTYPE_NONCONVEX</span><span class="p">;</span>

<span class="cm">/* call to KTR_mip_init_problem */</span>
<span class="n">nStatus</span> <span class="o">=</span> <span class="n">KTR_mip_init_problem</span> <span class="p">(</span>
        <span class="n">kc</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">objGoal</span><span class="p">,</span> <span class="n">objType</span><span class="p">,</span>
        <span class="n">objFnType</span><span class="p">,</span> <span class="n">xType</span><span class="p">,</span>
        <span class="n">xLoBnds</span><span class="p">,</span> <span class="n">xUpBnds</span><span class="p">,</span>
        <span class="n">m</span><span class="p">,</span> <span class="n">cType</span><span class="p">,</span> <span class="n">cFnType</span><span class="p">,</span> <span class="n">cLoBnds</span><span class="p">,</span> <span class="n">cUpBnds</span><span class="p">,</span>
        <span class="n">nnzJ</span><span class="p">,</span> <span class="n">jacIndexVars</span><span class="p">,</span> <span class="n">jacIndexCons</span><span class="p">,</span>
        <span class="n">nnzH</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">xInitial</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="cm">/* free memory */</span>
<span class="n">free</span><span class="p">(</span><span class="n">xType</span><span class="p">);</span>
<span class="n">free</span><span class="p">(</span><span class="n">cFnType</span><span class="p">);</span>
</pre></div>
</div>
<p>and the call to <a class="reference internal" href="../3_referenceManual/callableLibrary/API.html#KTR_solve" title="KTR_solve"><code class="xref c c-func docutils literal"><span class="pre">KTR_solve()</span></code></a> by a call to
<a class="reference internal" href="../3_referenceManual/callableLibrary/API.html#KTR_mip_solve" title="KTR_mip_solve"><code class="xref c c-func docutils literal"><span class="pre">KTR_mip_solve()</span></code></a> with the same arguments.
The Knitro log will look similar to what we observed in the AMPL example above.
Again, this example is quite unusual in the sense that the continuous solution is
already integer, which of course is not the case in general.</p>
</div>
<div class="section" id="object-oriented-c-example">
<h2>Object-oriented C++ example</h2>
<p>A MIP problem is defined and solved via the object-oriented interface by adding
additional problem information in the problem class.</p>
<p>In the following, we will define how to turn the toy example into a MINLP problem.
The <code class="docutils literal"><span class="pre">ProblemExample</span></code> class has to be extended with new definitions.</p>
<p>In the function <code class="docutils literal"><span class="pre">setObjectiveProperties()</span></code>, the function
<code class="docutils literal"><span class="pre">KTRProblem::setObjFnType(int</span> <span class="pre">fnType)</span></code> is used to define the objective
function type:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">setObjFnType</span><span class="p">(</span><span class="n">KNITRO</span><span class="p">::</span><span class="n">KTREnums</span><span class="p">::</span><span class="n">FunctionType</span><span class="p">::</span><span class="n">Convex</span><span class="p">);</span>
</pre></div>
</div>
<p>In the function <code class="xref c c-func docutils literal"><span class="pre">setConstraintProperties()</span></code>, the constraint function
types are defined with the function <code class="docutils literal"><span class="pre">KTRProblem::setConFnTypes(int</span> <span class="pre">id,</span> <span class="pre">int</span> <span class="pre">fnType)</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">setConFnTypes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">KNITRO</span><span class="p">::</span><span class="n">KTREnums</span><span class="p">::</span><span class="n">FunctionType</span><span class="p">::</span><span class="n">Convex</span><span class="p">);</span>
<span class="n">setConFnTypes</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">KNITRO</span><span class="p">::</span><span class="n">KTREnums</span><span class="p">::</span><span class="n">FunctionType</span><span class="p">::</span><span class="n">Nonconvex</span><span class="p">);</span>
</pre></div>
</div>
<p>In the function <code class="xref c c-func docutils literal"><span class="pre">setVariableProperties()</span></code>, the variable types are defined
with the function <code class="docutils literal"><span class="pre">KTRProblem::setVarFntypes(int</span> <span class="pre">fnTypes)</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">setVarFnTypes</span><span class="p">(</span><span class="n">KNITRO</span><span class="p">::</span><span class="n">KTREnums</span><span class="p">::</span><span class="n">VariableType</span><span class="p">::</span><span class="n">Integer</span><span class="p">);</span>
</pre></div>
</div>
<p>Without specifying a variable index, the function sets variable types
for all variables to integer.</p>
<p>This example uses the <code class="docutils literal"><span class="pre">KTRProblem</span></code> class to simplify implementing <code class="docutils literal"><span class="pre">KTRIProblem</span></code>. If using <code class="docutils literal"><span class="pre">KTRIProblem</span></code> only, the functions <code class="docutils literal"><span class="pre">KTRIProblem::getObjFnType</span></code>, <code class="docutils literal"><span class="pre">KTRIProblem::getConFnType</span></code>, and <code class="docutils literal"><span class="pre">KTRIProblem::getVarFnType</span></code> should be implemented to return the appropriate values.</p>
<p>The KNITRO log will look similar to what we observed in the AMPL example above.
Again, this example is quite unusual in the sense that the continuous solution is
already integer, which of course is not the case in general.</p>
</div>
<div class="section" id="minlp-options">
<h2>MINLP options</h2>
<p>Many user options are provided for the MIP features to tune performance, including
options for branching, node selection, rounding and heuristics for finding integer
feasible points.  User options specific to the MIP tools begin with  <em>mip_</em>.
It is recommended to experiment with several
of these options as they often can make a significant difference in performance.</p>
<table border="1" class="docutils">
<colgroup>
<col width="37%" />
<col width="63%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Name</th>
<th class="head">Meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><a class="reference internal" href="../3_referenceManual/userOptions.html#mip_branchrule" title="mip_branchrule"><code class="xref c c-type docutils literal"><span class="pre">mip_branchrule</span></code></a></td>
<td>MIP branching rule</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../3_referenceManual/userOptions.html#mip_debug" title="mip_debug"><code class="xref c c-type docutils literal"><span class="pre">mip_debug</span></code></a></td>
<td>MIP debugging level (0=none, 1=all)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../3_referenceManual/userOptions.html#mip_gub_branch" title="mip_gub_branch"><code class="xref c c-type docutils literal"><span class="pre">mip_gub_branch</span></code></a></td>
<td>Branch on GUBs (0=no, 1=yes)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../3_referenceManual/userOptions.html#mip_heuristic" title="mip_heuristic"><code class="xref c c-type docutils literal"><span class="pre">mip_heuristic</span></code></a></td>
<td>MIP heuristic search</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../3_referenceManual/userOptions.html#mip_heuristic_maxit" title="mip_heuristic_maxit"><code class="xref c c-type docutils literal"><span class="pre">mip_heuristic_maxit</span></code></a></td>
<td>MIP heuristic iteration limit</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../3_referenceManual/userOptions.html#mip_heuristic_terminate" title="mip_heuristic_terminate"><code class="xref c c-type docutils literal"><span class="pre">mip_heuristic_terminate</span></code></a></td>
<td>MIP heuristic termination condition</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../3_referenceManual/userOptions.html#mip_implications" title="mip_implications"><code class="xref c c-type docutils literal"><span class="pre">mip_implications</span></code></a></td>
<td>Add logical implications (0=no, 1=yes)</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../3_referenceManual/userOptions.html#mip_integer_tol" title="mip_integer_tol"><code class="xref c c-type docutils literal"><span class="pre">mip_integer_tol</span></code></a></td>
<td>Threshold for deciding integrality</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../3_referenceManual/userOptions.html#mip_integral_gap_abs" title="mip_integral_gap_abs"><code class="xref c c-type docutils literal"><span class="pre">mip_integral_gap_abs</span></code></a></td>
<td>Absolute integrality gap stop tolerance</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../3_referenceManual/userOptions.html#mip_integral_gap_rel" title="mip_integral_gap_rel"><code class="xref c c-type docutils literal"><span class="pre">mip_integral_gap_rel</span></code></a></td>
<td>Relative integrality gap stop tolerance</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../3_referenceManual/userOptions.html#mip_intvar_strategy" title="mip_intvar_strategy"><code class="xref c c-type docutils literal"><span class="pre">mip_intvar_strategy</span></code></a></td>
<td>Treatment of integer variables</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../3_referenceManual/userOptions.html#mip_knapsack" title="mip_knapsack"><code class="xref c c-type docutils literal"><span class="pre">mip_knapsack</span></code></a></td>
<td>Add knapsack cuts (0=no, 1=ineqs, 2=ineqs+eqs)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../3_referenceManual/userOptions.html#mip_lpalg" title="mip_lpalg"><code class="xref c c-type docutils literal"><span class="pre">mip_lpalg</span></code></a></td>
<td>LP subproblem algorithm</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../3_referenceManual/userOptions.html#mip_maxnodes" title="mip_maxnodes"><code class="xref c c-type docutils literal"><span class="pre">mip_maxnodes</span></code></a></td>
<td>Maximum nodes explored</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../3_referenceManual/userOptions.html#mip_maxsolves" title="mip_maxsolves"><code class="xref c c-type docutils literal"><span class="pre">mip_maxsolves</span></code></a></td>
<td>Maximum subproblem solves</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../3_referenceManual/userOptions.html#mip_maxtime_cpu" title="mip_maxtime_cpu"><code class="xref c c-type docutils literal"><span class="pre">mip_maxtime_cpu</span></code></a></td>
<td>Maximum CPU time in seconds for MIP</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../3_referenceManual/userOptions.html#mip_maxtime_real" title="mip_maxtime_real"><code class="xref c c-type docutils literal"><span class="pre">mip_maxtime_real</span></code></a></td>
<td>Maximum real in seconds time for MIP</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../3_referenceManual/userOptions.html#mip_method" title="mip_method"><code class="xref c c-type docutils literal"><span class="pre">mip_method</span></code></a></td>
<td>MIP method (0=auto, 1=BB, 2=HQG, 3=MISQP)</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../3_referenceManual/userOptions.html#mip_nodealg" title="mip_nodealg"><code class="xref c c-type docutils literal"><span class="pre">mip_nodealg</span></code></a></td>
<td>Standard node relaxation algorithm</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../3_referenceManual/userOptions.html#mip_outinterval" title="mip_outinterval"><code class="xref c c-type docutils literal"><span class="pre">mip_outinterval</span></code></a></td>
<td>MIP output interval</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../3_referenceManual/userOptions.html#mip_outlevel" title="mip_outlevel"><code class="xref c c-type docutils literal"><span class="pre">mip_outlevel</span></code></a></td>
<td>MIP output level</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../3_referenceManual/userOptions.html#mip_outsub" title="mip_outsub"><code class="xref c c-type docutils literal"><span class="pre">mip_outsub</span></code></a></td>
<td>Enable MIP subproblem output</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../3_referenceManual/userOptions.html#mip_pseudoinit" title="mip_pseudoinit"><code class="xref c c-type docutils literal"><span class="pre">mip_pseudoinit</span></code></a></td>
<td>Pseudo-cost initialization</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../3_referenceManual/userOptions.html#mip_relaxable" title="mip_relaxable"><code class="xref c c-type docutils literal"><span class="pre">mip_relaxable</span></code></a></td>
<td>Are integer variables relaxable?</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../3_referenceManual/userOptions.html#mip_rootalg" title="mip_rootalg"><code class="xref c c-type docutils literal"><span class="pre">mip_rootalg</span></code></a></td>
<td>Root node relaxation algorithm</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../3_referenceManual/userOptions.html#mip_rounding" title="mip_rounding"><code class="xref c c-type docutils literal"><span class="pre">mip_rounding</span></code></a></td>
<td>MIP rounding rule</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../3_referenceManual/userOptions.html#mip_selectrule" title="mip_selectrule"><code class="xref c c-type docutils literal"><span class="pre">mip_selectrule</span></code></a></td>
<td>MIP node selection rule</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../3_referenceManual/userOptions.html#mip_strong_candlim" title="mip_strong_candlim"><code class="xref c c-type docutils literal"><span class="pre">mip_strong_candlim</span></code></a></td>
<td>Strong branching candidate limit</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../3_referenceManual/userOptions.html#mip_strong_level" title="mip_strong_level"><code class="xref c c-type docutils literal"><span class="pre">mip_strong_level</span></code></a></td>
<td>Strong branching tree level limit</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="../3_referenceManual/userOptions.html#mip_strong_maxit" title="mip_strong_maxit"><code class="xref c c-type docutils literal"><span class="pre">mip_strong_maxit</span></code></a></td>
<td>Strong branching iteration limit</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="../3_referenceManual/userOptions.html#mip_terminate" title="mip_terminate"><code class="xref c c-type docutils literal"><span class="pre">mip_terminate</span></code></a></td>
<td>Termination condition for MIP</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="algorithms-methods">
<h2>Algorithms/Methods</h2>
<p>The default MINLP method in Knitro is a standard implementation of branch-and-bound
for nonlinear optimization.  This method involves solving a relaxed, continuous nonlinear
optimization subproblem at every node of the branch-and-bounds tree.  This method
is generally the preferred method.  It is primarily designed for convex models, and in this
case the integrality gap measure can be trusted.  It can also be applied to non-convex models,
and often works well on these models. However it may sometimes get stuck at integer feasible
points that are not globally optimal solutions when the model in nonconvex.
In addition, the integrality gap meaure
may not be accurate since this measure is based on the assumption that the nonlinear
optimization subproblems are always solved to global optimality (which may not be the case
when the model is nonconvex).</p>
<p>The hybrid Quesada-Grossman (HQG) method in Knitro is a variant of branch-and-bound
for MINLP.  It maintains one branch-and-bound tree but solves linear programming (LP)
subproblems at most of the nodes, while only occasionally solving nonlinear
optimization subproblems at integer feasible nodes.  The solutions of the LP
subproblems are used to generate outer approximations/cuts, which are continually
added to the master problem.  This method should generally only be applied to convex
models since the outer approximations are only valid when the model is convex.
This method will typically take many more nodes to solve compared with the standard
branch-and-bound method, but the node subproblems are often easier to solve
since most of them are LPs.</p>
<p>The third method (MISQP) is a largely heuristic method that attempts to extend the
SQP method for continuous, nonlinear optimization to the case where there are
integer variables.  This method is primarily designed for small problems (e.g. less
than 100 variables) where function evaluations may involve expensive black-box
simulations and derivatives may not be available.  In contrast to the
other MINLP algorithms in Knitro, this method is able to handle models where the integer
variables cannot be relaxed.  This means that the simulations or function evaluations
can only occur when integer variables are at integer values (e.g. the integer
variables may have no meaning at non-integral values).  This method will typically
converge in far fewer function evaluations compared with the other MINLP
methods in Knitro and is primarily intended for small problems where these evaluations
are the dominant cost.  This method can be applied to either convex or non-convex
models, but may converge to non-global integer, feasible points.  However, since this algorithm
runs similarly to the continuous SQP algorithm, you can apply the parallel multi-start
feature (see Section <a class="reference internal" href="multistart.html#sec-multistart"><span class="std std-ref">Multistart</span></a>) to the MISQP method to increase the
chances of finding the global solution.</p>
</div>
<div class="section" id="branching-priorities">
<h2>Branching priorities</h2>
<p>It is also possible to specify branching priorities in Knitro.
Priorities must be positive numbers (variables with non-positive values
are ignored). Variables with higher priority values will be considered
for branching before variables with lower priority values. When priorities
for a subset of variables are equal, the branching rule is applied
as a tiebreaker.</p>
<p class="rubric">Branching priorities in AMPL</p>
<p>Branching priorities for integer variables
can be specified in AMPL using the AMPL suffixes feature
(see <a class="reference internal" href="../3_referenceManual/knitroamplReference.html#sec-ampl-suffixes"><span class="std std-ref">AMPL suffixes defined for Knitro</span></a>) as shown below.</p>
<div class="highlight-none"><div class="highlight"><pre><span></span>...
ampl: var x{j in 1..3} &gt;= 0 integer;
...
ampl: suffix priority IN, integer, &gt;=0, &lt;=9999;
ampl: let x[1].priority := 5;
ampl: let x[2].priority := 1;
ampl: let x[3].priority := 10;
</pre></div>
</div>
<p>See the AMPL documentation for more information on the &#8221;.priority &#8221;
suffix.</p>
<p class="rubric">Branching priorities in the callable library API</p>
<p>Branching priorities for integer variables
can be specified through the callable library interface using
the function shown below.</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">KTR_mip_set_branching_priorities</span> <span class="p">(</span>      <span class="n">KTR_context_ptr</span> <span class="n">kc</span><span class="p">,</span>
                                      <span class="k">const</span> <span class="kt">int</span> <span class="o">*</span> <span class="k">const</span>     <span class="n">xPriorities</span><span class="p">);</span>
</pre></div>
</div>
<p>The array <em>xPriorities</em> has length <em>&#8220;n&#8221;</em>, where <em>n</em> is the number of variables.
Values for continuous variables are ignored.
Knitro makes a local copy of all inputs, so the application may free memory after the call. This
routine must be called after calling <a class="reference internal" href="../3_referenceManual/callableLibrary/API.html#KTR_mip_init_problem" title="KTR_mip_init_problem"><code class="xref c c-func docutils literal"><span class="pre">KTR_mip_init_problem()</span></code></a> and before calling
<a class="reference internal" href="../3_referenceManual/callableLibrary/API.html#KTR_mip_solve" title="KTR_mip_solve"><code class="xref c c-func docutils literal"><span class="pre">KTR_mip_solve()</span></code></a>.</p>
<p class="rubric">Branching priorities in the object-oriented interface</p>
<p>Branching priorities for integer variables
can be specified through the object-oriented interface using
the function shown below.</p>
<div class="highlight-cpp"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="n">KTRSolver</span><span class="o">::</span><span class="n">mipSetBranchingPriorities</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">xPriorities</span><span class="p">);</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">std::vector&lt;int&gt;</span></code> <em>xPriorities</em> has length <em>&#8220;n&#8221;</em>, where <em>n</em> is the number of variables.
Values for continuous variables are ignored.
This method must be called after calling the <code class="docutils literal"><span class="pre">KTRSolver</span></code> constructor and before calling
<code class="docutils literal"><span class="pre">KTRSolver::solve()</span></code>.</p>
</div>
<div class="section" id="special-treatment-of-integer-variables">
<h2>Special Treatment of Integer Variables</h2>
<p>You can specify special treatment of integer variables using the
<a class="reference internal" href="../3_referenceManual/userOptions.html#mip_intvar_strategy" title="mip_intvar_strategy"><code class="xref c c-type docutils literal"><span class="pre">mip_intvar_strategy</span></code></a> user option in Knitro.  In particularly, you can use this
option to specify that all integer variables are relaxed, or that all binary variables
should be converted to complementarity constraints (see Section <a class="reference internal" href="complementarity.html#sec-complementarity"><span class="std std-ref">Complementarity constraints</span></a> for a
description of complementarity constraints).</p>
<p>In addition you can specify special treatments of individual integer variables through
the callable library interface function</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">int</span>  <span class="n">KNITRO_API</span> <span class="nf">KTR_mip_set_intvar_strategy</span>
    <span class="p">(</span>      <span class="n">KTR_context_ptr</span> <span class="n">kc</span><span class="p">,</span>
     <span class="k">const</span> <span class="kt">int</span>             <span class="n">xIndex</span><span class="p">,</span>
     <span class="k">const</span> <span class="kt">int</span>             <span class="n">xStrategy</span><span class="p">);</span>
</pre></div>
</div>
<p>Here <em>xIndex</em> specifies the index of the integer variable you want to apply the
special treatment to, and <em>xStrategy</em> specifies how you want to handle that
particular integer variable (e.g., no special treatment, relax, or convert to a
complementarity constraint).</p>
<p>Special strategies for integer variables
can be specified in the AMPL interface using the <em>intvarstrategy</em> AMPL suffix,
and in the MATLAB interface using the <em>extendedFeatures.xIntStrategy</em> structure.</p>
</div>
<div class="section" id="minlp-callbacks">
<h2>MINLP callbacks</h2>
<p>The Knitro MINLP procedure provides a user callback utility that can be used
in the callable library API to
perform some user task after each node is processed in the branch-and-bound
tree.  This callback function is set by calling the following function:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="kt">int</span>  <span class="n">KNITRO_API</span> <span class="nf">KTR_set_mip_node_callback</span> <span class="p">(</span><span class="n">KTR_context_ptr</span>       <span class="n">kc</span><span class="p">,</span>
                                           <span class="n">KTR_callback</span> <span class="o">*</span> <span class="k">const</span>  <span class="n">fnPtr</span><span class="p">);</span>
</pre></div>
</div>
<p>See the <a class="reference internal" href="../3_referenceManual/callableLibrary/API.html#sec-api"><span class="std std-ref">Knitro API</span></a> section in the Reference Manual for details on setting
this callback function and the prototype for this callback function.</p>
</div>
<div class="section" id="determining-convexity">
<h2>Determining convexity</h2>
<p>Knowing whether or not a function is convex may be useful in methods for
mixed integer programming as linearizations derived from convex functions
can be used as outer approximations of those constraints.
These outer approximations are useful
in computing lower bounds.  The callable library for the mixed integer
programming API allows for the user to specify whether or not the problem
functions (objective and constraints) are convex or not.  If unknown,
they can be marked as such.</p>
<p>A function <em>f</em> is convex if for any two points <em>x</em> and <em>y</em>, we have</p>
<div class="math">
<p><span class="math">f(\alpha x + (1-\alpha)y) \le \alpha f(x)+(1-\alpha)f(y), \;
  \mbox{for all} \; \alpha \in [0, 1].</span></p>
</div><p>In identifying the objective or constraints as convex, we are assuming
a problem form where the objective is being minimized and the constraints
are all formulated as &#8220;less than or equal to&#8221; constraints. If we
are maximizing or looking at &#8220;greater than or equal to&#8221; constraints,
then the objective or constraint should be labeled as convex if its negation
is convex.</p>
<p>More specifically, the objective function <span class="math">f(x)</span> should be marked as convex
if when minimizing <span class="math">f(x)</span> satisfies the above convexity condition, or if when
maximizing <span class="math">-f(x)</span> satisfies it. A constraint <span class="math">c_i(x)</span>
should be labeled as convex if:</p>
<ul class="simple">
<li><span class="math">c^L</span> is infinite, <span class="math">c^U</span> is finite and <span class="math">c_i(x)</span>
satisfies the convexity condition; or</li>
<li><span class="math">c^L</span> is finite, <span class="math">c^U</span> is infinite and <span class="math">-c_i(x)</span>
satisfies the convexity condition; or</li>
<li><span class="math">c_i(x)</span> is linear.</li>
</ul>
<p>All linear functions are convex.  Any nonlinear
equality constraint is nonconvex.</p>
<p>The MIP solvers in
Knitro are designed for convex problems (problems where the
objective and all the constraints are convex).  If one or more
functions are nonconvex, these solvers are only heuristics and
may terminate at non-optimal points. The continuous solvers in
Knitro can handle either convex or nonconvex models.
However, for nonconvex models, they may converge to local
(rather than global) optimal solutions.</p>
</div>
<div class="section" id="additional-examples">
<h2>Additional examples</h2>
<p>Examples for solving MINLP problems using the MATLAB, C, C++, Java, C#, Python and R interfaces are
provided with the distribution in the knitromatlab and examples directories.</p>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="complementarity.html" class="btn btn-neutral float-right" title="Complementarity constraints" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="multistart.html" class="btn btn-neutral" title="Multistart" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, Artelys.

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'10.3.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  false
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>